[{"content":"","date":null,"permalink":"/","section":"CraftingCode","summary":"","title":"CraftingCode"},{"content":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.\n// Before Actions function UpdateName({}) { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =\u0026gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\u0026#34;/path\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Donde manejamos varias cosas manualmente, como el estado pendiente o el manejo de errores.\nDespués #React 19 permite pasarle una función asíncrona al hook useTransition, lo que nos permite manejar los estados pendientes, errores y formularios de forma automática.\n\u0026#34;use client\u0026#34;; import { redirect } from \u0026#34;next/navigation\u0026#34;; import { useState, useTransition } from \u0026#34;react\u0026#34;; export default function FormAction() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(\u0026#34;\u0026#34;); const [isPending, startTransition] = useTransition(); const updateName = (name: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Error updating name\u0026#34;); console.info(name); }, 3000); }); }; const handleSubmit = () =\u0026gt; { startTransition(async () =\u0026gt; { const error = await updateName(name); if (error.length \u0026gt; 0) { setError(error); return; } console.log(\u0026#34;Name updated!\u0026#34;); redirect(\u0026#34;/success\u0026#34;) }); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {isPending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Updating name...\u0026lt;/p\u0026gt;} {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Primero, pasamos la función asíncrona a startTransition, en este ejemplo si esta función devuelve un error lo mostramos, en caso contrario redirigimos a la página de éxito.\nY en medio de todo esto tenemos el estado isPending con el que mostramos un indicador de carga.\nAun así sigue siendo mucho código por ejemplo el error aún está siendo manejado manualmente.\nuseActionState #En el video anterior vimos cómo usando useTransition podíamos manejar un estado pendiente para formularios, pero aún estábamos manejando el estado de error manualmente con useState.\nconst handleSubmit = () =\u0026gt; { startTransition(async () =\u0026gt; { const error = await updateName(name); if (error.length \u0026gt; 0) { setError(error); return; } console.log(\u0026#34;Name updated!\u0026#34;); redirect(\u0026#34;/success\u0026#34;) }); }; React 19 introduce un nuevo hook llamado useActionState que nos deja actualizar el estado basado en el resultado de una acción de formulario.\nEl hook recibe dos parámetros, una función (que puede ser asíncrona) y un objeto que es el estado inicial de la acción.\nLa función es llamada cada vez que hacemos submit al formulario, si hacemos submit y revisamos el previous state veremos que es igual a “no hay nombre” (estado inicial).\nSi llamamos las subsecuentes veces previousState debería ser igual al nombre que escribimos en el formulario.\n\u0026#34;use client\u0026#34;; import { useRouter } from \u0026#34;next/navigation\u0026#34;; import { useActionState } from \u0026#34;react\u0026#34;; import { Input } from \u0026#34;@/components/ui/input\u0026#34;; import { Button } from \u0026#34;@/components/ui/button\u0026#34;; type ActionState = string; export default function ActionState() { const router = useRouter(); const updateName = (name: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(name); }, 1000); }); }; const [error, submitAction, pending] = useActionState\u0026lt;string | null, FormData\u0026gt;( async (previousState, formData: FormData) =\u0026gt; { try { console.log(\u0026#34;previousState\u0026#34;) console.log(previousState) const name = formData.get(\u0026#34;name\u0026#34;) as string; const error = await updateName(name); if (error.length \u0026gt; 0) { return error; } else { return null; } } catch (e) { return \u0026#34;Error\u0026#34;; } }, \u0026#34;No hay nombre\u0026#34; ); return ( \u0026lt;form action={submitAction} className=\u0026#34;flex flex-col w-1/2 my-0 mx-auto p-5 gap-3\u0026#34; \u0026gt; \u0026lt;Input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Type your name\u0026#34; disabled={pending} /\u0026gt; \u0026lt;Button type=\u0026#34;submit\u0026#34; disabled={pending}\u0026gt; Update \u0026lt;/Button\u0026gt; {error \u0026amp;\u0026amp; !pending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} {pending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Loading\u0026lt;/p\u0026gt;} \u0026lt;/form\u0026gt; ); } Aja ¿y cómo conectamos este hook al formulario?, fácil el hook retorna tres valores: el estado actual del formulario, una función de acción y un boleano de carga al que llamaremos isPending.\n\u0026#34;use client\u0026#34;; import { useRouter } from \u0026#34;next/navigation\u0026#34;; import { useActionState } from \u0026#34;react\u0026#34;; import { Input } from \u0026#34;@/components/ui/input\u0026#34;; import { Button } from \u0026#34;@/components/ui/button\u0026#34;; type ActionState = string; export default function ActionState() { const router = useRouter(); const updateName = (name: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(name); }, 1000); }); }; const [error, submitAction, pending] = useActionState\u0026lt; string | null, FormData \u0026gt;(async (_, formData: FormData) =\u0026gt; { try { const name = formData.get(\u0026#34;name\u0026#34;) as string; await updateName(name); router.push(\u0026#34;/\u0026#34;); return null; } catch (e) { return \u0026#34;Error\u0026#34;; } }, \u0026#34;No hay nombre\u0026#34;); return ( \u0026lt;form action={submitAction} className=\u0026#34;flex flex-col w-1/2 my-0 mx-auto p-5 gap-3\u0026#34; \u0026gt; \u0026lt;Input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Type your name\u0026#34; disabled={pending} /\u0026gt; \u0026lt;Button type=\u0026#34;submit\u0026#34; disabled={pending}\u0026gt; Update \u0026lt;/Button\u0026gt; {error \u0026amp;\u0026amp; !pending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} {pending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Loading\u0026lt;/p\u0026gt;} \u0026lt;/form\u0026gt; ); } La función de acción es la que nos interesa, a partir de React 19 los formularios pueden recibir una acción como función.\nEn el ejemplo anterior tenemos tenemos el estado de carga, el error mostrado y la redirección en caso de éxito.\n¡Suscríbete a nuestro boletín para recibir nuestro contenido! ","date":"11 de junio de 2024","permalink":"/react-19/","section":"CraftingCode","summary":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.","title":"Lo nuevo en React 19"},{"content":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.\n// Before Actions function UpdateName({}) { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =\u0026gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\u0026#34;/path\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Donde manejamos varias cosas manualmente, como el estado pendiente o el manejo de errores.\nDespués #React 19 permite pasarle una función asíncrona al hook useTransition, lo que nos permite manejar los estados pendientes, errores y formularios de forma automática.\n\u0026#34;use client\u0026#34;; import { redirect } from \u0026#34;next/navigation\u0026#34;; import { useState, useTransition } from \u0026#34;react\u0026#34;; export default function FormAction() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(\u0026#34;\u0026#34;); const [isPending, startTransition] = useTransition(); const updateName = (name: string): Promise\u0026lt;string\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Error updating name\u0026#34;); console.info(name); }, 3000); }); }; const handleSubmit = () =\u0026gt; { startTransition(async () =\u0026gt; { const error = await updateName(name); if (error.length \u0026gt; 0) { setError(error); return; } console.log(\u0026#34;Name updated!\u0026#34;); redirect(\u0026#34;/success\u0026#34;) }); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {isPending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Updating name...\u0026lt;/p\u0026gt;} {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Primero, pasamos la función asíncrona a startTransition, en este ejemplo si esta función devuelve un error lo mostramos, en caso contrario redirigimos a la página de éxito.\nY en medio de todo esto tenemos el estado isPending con el que mostramos un indicador de carga.\nAun así sigue siendo mucho código por ejemplo el error aún está siendo manejado manualmente.\nEn el siguiente artículo veremos otro escenario: las actualizaciones optimistas con lo que simplificamos este código.\n¡Suscríbete a nuestro boletín para recibir nuestro contenido! ","date":"11 de junio de 2024","permalink":"/posts/react-19-actions/","section":"Posts","summary":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.","title":"Lo nuevo en React 19: Actions"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]