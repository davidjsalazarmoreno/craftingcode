[{"content":"","date":null,"permalink":"/","section":"CraftingCode","summary":"","title":"CraftingCode"},{"content":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.\n// Before Actions function UpdateName({}) { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =\u0026gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\u0026#34;/path\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Donde manejamos varias cosas manualmente, como el estado pendiente o el manejo de errores.\nDespués #React 19 permite pasarle una función asíncrona al hook useTransition, lo que nos permite manejar los estados pendientes, errores y formularios de forma automática.\n\u0026#34;use client\u0026#34;; import { redirect } from \u0026#34;next/navigation\u0026#34;; import { useState, useTransition } from \u0026#34;react\u0026#34;; export default function FormAction() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(\u0026#34;\u0026#34;); const [isPending, startTransition] = useTransition(); const updateName = (name: string) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#34;Error updating name\u0026#34;); console.info(name); }, 3000); }); }; const handleSubmit = () =\u0026gt; { startTransition(async () =\u0026gt; { const error = await updateName(name); if (error.length \u0026gt; 0) { setError(error); return; } console.log(\u0026#34;Name updated!\u0026#34;); redirect(\u0026#34;/success\u0026#34;) }); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {isPending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Updating name...\u0026lt;/p\u0026gt;} {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Primero, pasamos la función asíncrona a startTransition, en este ejemplo si esta función devuelve un error lo mostramos, en caso contrario redirigimos a la página de éxito.\nY en medio de todo esto tenemos el estado isPending con el que mostramos un indicador de carga.\nAun así sigue siendo mucho código por ejemplo el error aún está siendo manejado manualmente.\nEn el siguiente artículo veremos otro escenario: las actualizaciones optimistas con lo que simplificamos este código.\n","date":"11 de junio de 2024","permalink":"/react-19/","section":"CraftingCode","summary":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.","title":"Lo nuevo en React 19"},{"content":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.\n// Before Actions function UpdateName({}) { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =\u0026gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\u0026#34;/path\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Donde manejamos varias cosas manualmente, como el estado pendiente o el manejo de errores.\nDespués #React 19 permite pasarle una función asíncrona al hook useTransition, lo que nos permite manejar los estados pendientes, errores y formularios de forma automática.\n\u0026#34;use client\u0026#34;; import { redirect } from \u0026#34;next/navigation\u0026#34;; import { useState, useTransition } from \u0026#34;react\u0026#34;; export default function FormAction() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [error, setError] = useState(\u0026#34;\u0026#34;); const [isPending, startTransition] = useTransition(); const updateName = (name: string) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#34;Error updating name\u0026#34;); console.info(name); }, 3000); }); }; const handleSubmit = () =\u0026gt; { startTransition(async () =\u0026gt; { const error = await updateName(name); if (error.length \u0026gt; 0) { setError(error); return; } console.log(\u0026#34;Name updated!\u0026#34;); redirect(\u0026#34;/success\u0026#34;) }); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={name} onChange={(event) =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit} disabled={isPending}\u0026gt; Update \u0026lt;/button\u0026gt; {isPending \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Updating name...\u0026lt;/p\u0026gt;} {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Primero, pasamos la función asíncrona a startTransition, en este ejemplo si esta función devuelve un error lo mostramos, en caso contrario redirigimos a la página de éxito.\nY en medio de todo esto tenemos el estado isPending con el que mostramos un indicador de carga.\nAun así sigue siendo mucho código por ejemplo el error aún está siendo manejado manualmente.\nEn el siguiente artículo veremos otro escenario: las actualizaciones optimistas con lo que simplificamos este código.\n","date":"11 de junio de 2024","permalink":"/posts/react-19-actions/","section":"Posts","summary":"Actions #Antes #Los actions buscan simplificar el código de React, veamos un caso muy común: una mutación de datos y luego actualizar el estado en respuesta.","title":"Lo nuevo en React 19: Actions"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]